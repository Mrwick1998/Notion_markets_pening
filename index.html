<script>
  // ===== Anzeige-Zeitzone (DE) =====
  const TARGET_TZ = "Europe/Berlin";

  // ===== Börsen (nur 4) =====
  const EXCHANGES = [
    { name: "London Stock Exchange (LSE)", city: "London", countryNames: ["United Kingdom"], tz: "Europe/London", open: "08:00", close: "16:30", weekdays: [1,2,3,4,5] },
    { name: "New York (NYSE & Nasdaq)",    city: "New York", countryNames: ["United States of America"], tz: "America/New_York", open: "09:30", close: "16:00", weekdays: [1,2,3,4,5] },
    { name: "Tokyo Stock Exchange (TSE)",  city: "Tokyo", countryNames: ["Japan"], tz: "Asia/Tokyo", open: "09:00", close: "15:00", weekdays: [1,2,3,4,5] },
    { name: "Sydney (ASX)",                city: "Sydney", countryNames: ["Australia"], tz: "Australia/Sydney", open: "10:00", close: "16:00", weekdays: [1,2,3,4,5] },
  ];

  // ===== Zeit-Helfer =====
  const DateTime = luxon.DateTime;
  function parseHM(t){ const [h,m]=t.split(":").map(Number); return {h,m}; }

  function isOpenNow(ex, nowUtc = DateTime.utc()){
    const localNow = nowUtc.setZone(ex.tz);
    const dow = localNow.weekday; // 1..7
    if (!ex.weekdays.includes(dow)) return {open:false, localNow};
    const {h:oh, m:om} = parseHM(ex.open);
    const {h:ch, m:cm} = parseHM(ex.close);
    const openT  = localNow.set({ hour: oh, minute: om, second: 0, millisecond: 0 });
    const closeT = localNow.set({ hour: ch, minute: cm, second: 0, millisecond: 0 });
    const open = localNow >= openT && localNow <= closeT;
    return { open, localNow, openT, closeT };
  }

  function nextChangeDisplayDE(ex, nowUtc = DateTime.utc()){
    const st = isOpenNow(ex, nowUtc);
    if (st.open){
      return { label: "schließt um", timeDE: st.closeT.setZone(TARGET_TZ).toFormat("HH:mm") };
    } else {
      const localNow = nowUtc.setZone(ex.tz);
      for (let d=0; d<=10; d++){
        const candidate = localNow.plus({ days: d });
        if (ex.weekdays.includes(candidate.weekday)){
          const {h:oh,m:om} = parseHM(ex.open);
          const openC = candidate.set({ hour: oh, minute: om, second: 0, millisecond: 0 });
          if (d>0 || localNow < openC){
            return { label: "öffnet um", timeDE: openC.setZone(TARGET_TZ).toFormat("HH:mm") };
          }
        }
      }
      return { label: "öffnet um", timeDE: "—" };
    }
  }

  function todaysWindowInDE(ex, nowUtc = DateTime.utc()){
    const localNow = nowUtc.setZone(ex.tz);
    const {h:oh,m:om} = parseHM(ex.open);
    const {h:ch,m:cm} = parseHM(ex.close);
    const openLocal  = localNow.set({ hour: oh, minute: om, second: 0, millisecond: 0 });
    const closeLocal = localNow.set({ hour: ch, minute: cm, second: 0, millisecond: 0 });
    const openDE  = openLocal.setZone(TARGET_TZ);
    const closeDE = closeLocal.setZone(TARGET_TZ);
    return `${openDE.toFormat("HH:mm")} – ${closeDE.toFormat("HH:mm")}`;
  }

  // ===== Karte vorbereiten =====
  const mapWrap = document.getElementById('map-wrap');
  const svg = d3.select('#map');
  const g = svg.append('g');
  const projection = d3.geoEquirectangular();
  const path = d3.geoPath(projection);
  function resize(){
    const {clientWidth: w, clientHeight: h} = mapWrap;
    svg.attr('width', w).attr('height', h);
    projection.fitExtent([[10,10],[w-10, h-10]], {type:"Sphere"});
    draw(); // neu zeichnen
  }
  window.addEventListener('resize', resize);

  let countries = [];
  let countriesReady = false;

  // --- robust: Karte laden, aber UI funktioniert auch OHNE Karte ---
  fetch('https://unpkg.com/world-atlas@2/countries-110m.json')
    .then(r => r.json())
    .then(world => {
      countries = topojson.feature(world, world.objects.countries).features;
      countriesReady = true;
      resize();
      draw(); // erster Paint
    })
    .catch(() => {
      countriesReady = false; // kein Abbruch – Tabelle/Status laufen trotzdem
    });

  function getCountryName(d){
    return d && d.properties && (d.properties.name || d.properties.NAME || d.properties.admin) || '';
  }

  function draw(statusByName = new Map()){
    if (!countriesReady) return; // wenn Karte nicht da ist, einfach auslassen
    const sel = g.selectAll('path.country').data(countries, d => d.id);
    sel.enter()
      .append('path')
      .attr('class','country')
      .attr('d', path)
      .attr('fill', d => statusByName.get(getCountryName(d)) ? 'rgba(23,201,100,0.95)' : getComputedStyle(document.documentElement).getPropertyValue('--greyCountry').trim())
      .attr('stroke', getComputedStyle(document.documentElement).getPropertyValue('--stroke').trim())
      .attr('stroke-width', 0.6)
      .classed('open', d => !!statusByName.get(getCountryName(d)))
    .merge(sel)
      .transition().duration(400)
      .attr('fill', d => statusByName.get(getCountryName(d)) ? 'rgba(23,201,100,0.95)' : getComputedStyle(document.documentElement).getPropertyValue('--greyCountry').trim())
      .classed('open', d => !!statusByName.get(getCountryName(d)));
    sel.exit().remove();
  }

  // ===== LIVE-Badge / Zeitstempel =====
  const liveEl = () => document.getElementById('live-indicator');
  const updEl  = () => document.getElementById('last-updated');
  function pingLive(){ const el = liveEl(); if(!el) return; el.classList.add('blink'); setTimeout(()=>el.classList.remove('blink'), 1200); }
  function setUpdated(nowUtc){
    const stamp = nowUtc.setZone(TARGET_TZ).toFormat("dd.LL.yyyy HH:mm:ss 'Uhr'");
    const el = updEl(); if(el) el.textContent = `Zuletzt aktualisiert: ${stamp}`;
  }

  // ===== Tabelle + Status =====
  const tbodyEl = document.getElementById('markets-tbody');

  function updateAll(){
    try{
      const nowUtc = luxon.DateTime.utc();
      const openCountries = new Set();
      if (tbodyEl) tbodyEl.innerHTML = '';

      EXCHANGES.forEach(ex=>{
        const st = isOpenNow(ex, nowUtc);
        const nxt = nextChangeDisplayDE(ex, nowUtc);
        if (st.open) ex.countryNames.forEach(n => openCountries.add(n));

        if (tbodyEl){
          const tr = document.createElement('tr');
          const badgeClass = st.open ? 'open' : 'closed';
          const badgeText  = st.open ? 'OPEN' : 'CLOSED';
          tr.innerHTML = `
            <td>${ex.name}</td>
            <td>${ex.city}</td>
            <td>${todaysWindowInDE(ex, nowUtc)}</td>
            <td><span class="badge ${badgeClass}">${badgeText}</span></td>
            <td>${nxt.label} ${nxt.timeDE}</td>
          `;
          tbodyEl.appendChild(tr);
        }
      });

      // Karte färben (falls geladen)
      const statusByName = new Map();
      if (countriesReady){
        countries.forEach(c=>{
          const name = getCountryName(c);
          statusByName.set(name, openCountries.has(name));
        });
        draw(statusByName);
      }

      setUpdated(nowUtc);
      pingLive();
    } catch(e){
      // zeige leichten Hinweis im Zeitstempel, damit man es sieht
      const el = updEl(); if(el) el.textContent = "Zuletzt aktualisiert: Fehler beim Rendern";
      console.error(e);
    }
  }

  // --- WICHTIG: sofort starten, unabhängig von der Karte ---
  updateAll();
  setInterval(updateAll, 60*1000);
</script>
